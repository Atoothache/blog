(window.webpackJsonp=window.webpackJsonp||[]).push([[53],{324:function(e,s,t){"use strict";t.r(s);var n=t(13),a=Object(n.a)({},(function(){var e=this,s=e._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"docker离线安装部署"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#docker离线安装部署"}},[e._v("#")]),e._v(" Docker离线安装部署")]),e._v(" "),s("p",[e._v("docker安装包下载地址："),s("a",{attrs:{href:"https://download.docker.com/linux/static/stable/x86_64/",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://download.docker.com/linux/static/stable/x86_64/"),s("OutboundLink")],1)]),e._v(" "),s("h1",{attrs:{id:"创建系统配置文件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#创建系统配置文件"}},[e._v("#")]),e._v(" 创建系统配置文件")]),e._v(" "),s("p",[s("strong",[e._v("创建文件：")])]),e._v(" "),s("div",{staticClass:"language-shell extra-class"},[s("pre",{pre:!0,attrs:{class:"language-shell"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[e._v("vim")]),e._v(" /opt/docker/docker.service\n")])])]),s("p",[s("strong",[e._v("内容如下：")])]),e._v(" "),s("div",{staticClass:"language-shell extra-class"},[s("pre",{pre:!0,attrs:{class:"language-shell"}},[s("code",[s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v("Unit"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token assign-left variable"}},[e._v("Description")]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v("Docker Application Container Engine\n"),s("span",{pre:!0,attrs:{class:"token assign-left variable"}},[e._v("Documentation")]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v("https://docs.docker.com\n"),s("span",{pre:!0,attrs:{class:"token assign-left variable"}},[e._v("After")]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v("network-online.target firewalld.service\n"),s("span",{pre:!0,attrs:{class:"token assign-left variable"}},[e._v("Wants")]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v("network-online.target\n\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v("Service"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token assign-left variable"}},[e._v("Type")]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v("notify\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# the default is not to use systemd for cgroups because the delegate issues still")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# exists and systemd currently does not support the cgroup feature set required")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# for containers run by docker")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token assign-left variable"}},[e._v("ExecStart")]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v("/usr/bin/dockerd\n"),s("span",{pre:!0,attrs:{class:"token assign-left variable"}},[e._v("ExecReload")]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v("/bin/kill -s HUP "),s("span",{pre:!0,attrs:{class:"token variable"}},[e._v("$MAINPID")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Having non-zero Limit*s causes performance problems due to accounting overhead")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# in the kernel. We recommend using cgroups to do container-local accounting.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token assign-left variable"}},[e._v("LimitNOFILE")]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v("infinity\n"),s("span",{pre:!0,attrs:{class:"token assign-left variable"}},[e._v("LimitNPROC")]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v("infinity\n"),s("span",{pre:!0,attrs:{class:"token assign-left variable"}},[e._v("LimitCORE")]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v("infinity\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Uncomment TasksMax if your systemd version supports it.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# Only systemd 226 and above support this version.")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#TasksMax=infinity")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token assign-left variable"}},[e._v("TimeoutStartSec")]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("0")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# set delegate yes so that systemd does not reset the cgroups of docker containers")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token assign-left variable"}},[e._v("Delegate")]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v("yes\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# kill only the docker process, not all processes in the cgroup")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token assign-left variable"}},[e._v("KillMode")]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v("process\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("# restart the docker process if it exits prematurely")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token assign-left variable"}},[e._v("Restart")]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v("on-failure\n"),s("span",{pre:!0,attrs:{class:"token assign-left variable"}},[e._v("StartLimitBurst")]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),s("span",{pre:!0,attrs:{class:"token number"}},[e._v("3")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token assign-left variable"}},[e._v("StartLimitInterval")]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v("60s\n\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("[")]),e._v("Install"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[e._v("]")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token assign-left variable"}},[e._v("WantedBy")]),s("span",{pre:!0,attrs:{class:"token operator"}},[e._v("=")]),e._v("multi-user.target\n")])])]),s("p",[e._v("创建安装脚本")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("vim /opt/docker/install.sh\n")])])]),s("p",[e._v("内容如下：")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("#!/bin/sh\necho '解压tar包...'\ntar -xvf $1\necho '将docker目录移到/usr/bin目录下...'\ncp docker/* /usr/bin/\necho '将docker.service 移到/etc/systemd/system/ 目录...'\ncp docker.service /etc/systemd/system/\necho '添加文件权限...'\nchmod +x /etc/systemd/system/docker.service\necho '重新加载配置文件...'\nsystemctl daemon-reload\necho '启动docker...'\nsystemctl start docker\necho '设置开机自启...'\nsystemctl enable docker.service\necho 'docker安装成功...'\ndocker -v\n")])])]),s("h4",{attrs:{id:"创建卸载脚本"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#创建卸载脚本"}},[e._v("#")]),e._v(" 创建卸载脚本")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("vim /opt/docker/uninstall.sh\n")])])]),s("div",{staticClass:"language-shell extra-class"},[s("pre",{pre:!0,attrs:{class:"language-shell"}},[s("code",[s("span",{pre:!0,attrs:{class:"token shebang important"}},[e._v("#!/bin/sh")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token builtin class-name"}},[e._v("echo")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v("'删除docker.service...'")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("rm")]),e._v(" -f /etc/systemd/system/docker.service\n"),s("span",{pre:!0,attrs:{class:"token builtin class-name"}},[e._v("echo")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v("'删除docker文件...'")]),e._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[e._v("rm")]),e._v(" -rf /usr/bin/docker*\n"),s("span",{pre:!0,attrs:{class:"token builtin class-name"}},[e._v("echo")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v("'重新加载配置文件'")]),e._v("\nsystemctl daemon-reload\n"),s("span",{pre:!0,attrs:{class:"token builtin class-name"}},[e._v("echo")]),e._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[e._v("'卸载成功...'")]),e._v("\n")])])]),s("p",[s("strong",[e._v("执行安装脚本：")])]),e._v(" "),s("div",{staticClass:"language-shell extra-class"},[s("pre",{pre:!0,attrs:{class:"language-shell"}},[s("code",[s("span",{pre:!0,attrs:{class:"token function"}},[e._v("sh")]),e._v(" install.sh docker-20.10.9.tgz\n")])])]),s("h1",{attrs:{id:"配置国内源"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#配置国内源"}},[e._v("#")]),e._v(" 配置国内源")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('vim /etc/docker/daemon.json\n\n{\n "registry-mirrors" : [\n   "https://mirror.ccs.tencentyun.com",\n   "http://registry.docker-cn.com",\n   "http://docker.mirrors.ustc.edu.cn",\n   "http://hub-mirror.c.163.com"\n ],\n "insecure-registries" : [\n   "registry.docker-cn.com",\n   "docker.mirrors.ustc.edu.cn"\n ],\n "debug" : true,\n "experimental" : true\n}\n')])])]),s("div",{staticClass:"language-shell extra-class"},[s("pre",{pre:!0,attrs:{class:"language-shell"}},[s("code",[e._v("systemctl daemon-reload\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[e._v("#重启docker")]),e._v("\nsystemctl restart docker.service\n")])])]),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("安装过程遇到的问题：\n1、现象\n\n使用systemctl start docker启动很慢，并且呈现卡死状态，无任何反应。\n\n使用systemctl status docker发现docker一直处于Active: activating (start)\n\n2、可能的原因\n 服务器重启之后防火墙先于docker重启，docker无法操作防火墙导致重启卡死。\n\n3、解决方法\n\n关闭防火墙systemctl stop firewalld并查看关闭情况\n重启服务器\n启动docker systemctl start docker 并查看启动情况\n开启防火墙 systemctl start firewalld\n\n————————————————\n\n版权声明：本文为CSDN博主「一恍过去」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。\n\n原文链接：https://blog.csdn.net/zhuocailing3390/article/details/121797180\n\n")])])]),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("先介绍一下虚拟机的网络模式\n生成的虚拟设备\n\nVMnet0：用于虚拟桥接网络下的虚拟交换机\nVMnet1：用于虚拟Host-Only网络下的虚拟交换机\nVMnet8：用于虚拟NAT网络下的虚拟交换机\nVMware NetworkAdepter VMnet1：Host用于与Host-Only虚拟网络进行通信的虚拟网卡\nVMware NetworkAdepter VMnet8：Host用于与NAT虚拟网络进行通信的虚拟网卡\n\n一般具有这样的对应关系\n桥接\n在这种模式下，VMware虚拟出来的操作系统就像是局域网中的一台独立的主机，它可以访问网内任何一台机器。需要手工为虚拟系统配置IP地址、子网掩码，而且还要和宿主机器处于同一网段，这样虚拟系统才能和宿主机器进行通信。同时，由于这个虚拟系统是局域网中的一个独立的主机系统，那么就可以手工配置它的TCP/IP配置信息，以实现通过局域网的网关或路由器访问互联网。\n\nNAT\n使用NAT模式，就是让虚拟系统借助NAT(网络地址转换)功能，通过宿主机器所在的网络来访问公网。也就是说，使用NAT模式可以实现在虚拟系统里访问互联网。NAT模式下的虚拟系统的TCP/IP配置信息是由VMnet8(NAT)虚拟网络的DHCP服务器提供的，无法进行手工修改，因此虚拟系统也就无法和本局域网中的其他真实主机进行通讯。采用NAT模式最大的优势是虚拟系统接入互联网非常简单，不需要进行任何其他的配置，只需要主机器能访问互联网即可。这种情况下，主机可以ping通虚拟机，虚拟机也能ping通主机。\nHost-Only\nHost-Only模式其实就是NAT模式去除了虚拟NAT设备，然后使用VMware Network Adapter VMnet1虚拟网卡连接VMnet1虚拟交换机来与虚拟机通信的，Host-Only模式将虚拟机与外网隔开，使得虚拟机成为一个独立的系统，只与主机相互通讯。\n\n关于docker的网络模式\ndocker使用linux桥接，在宿主机虚拟一个Docker容器网桥(docker0)，Docker启动一个容器时会根据Docker网桥的网段分配给容器一个IP地址，称为Container-IP，同时Docker网桥是每个容器的默认网关。因为在同一宿主机内的容器都接入同一个网桥，这样容器之间就能够通过容器的Container-IP直接通信。\n\n由于docker网桥是虚拟出来的，外部网络无法寻址到 ，也就是说外部网络无法直接通过container_ip来访问容器，此时就需要使用端口映射（映射容器端口到宿主主机），docker run创建容器时候通过 -p 或 -P 参数来启用，访问容器的时候就通过[宿主机IP]:[容器端口]访问容器\n\n四种网络模式总览\n\nhost模式 –net=host 容器和宿主机共享Network namespace。\ncontainer模式 –net=container:NAME_or_ID 容器和另外一个容器共享Network namespace。\nnone模式 –net=none 容器有独立的Network namespace，但并没有对其进行任何网络设置，如分配veth pair 和网桥连接，配置IP等。\nbridge模式 –net=bridge （默认为该模式）\nHost模式\n容器将不会获得一个独立的Network Namespace，而是和宿主机共用一个Network Namespace。容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口。但是，容器的其他方面，如文件系统、进程列表等还是和宿主机隔离的。\n\n使用host模式的容器可以直接使用宿主机的IP地址与外界通信，容器内部的服务端口也可以使用宿主机的端口，不需要进行NAT，host最大的优势就是网络性能比较好，但是docker host上已经使用的端口就不能再用了，网络的隔离性不好。\n\ncontainer模式\n指定新创建的容器和已经存在的一个容器共享一个 Network Namespace，而不是和宿主机共享。新创建的容器不会创建自己的网卡，配置自己的 IP，而是和一个指定的容器共享 IP、端口范围等。同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。两个容器的进程可以通过 lo 网卡设备通信。\n\n[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-nZgeXJwP-1652531930546)(D:\\Utilities\\Typora\\images\\webp)]\n\nnone模式\nnone模式，Docker容器拥有自己的Network Namespace，但是，并不为Docker容器进行任何网络配置。也就是说，这个Docker容器没有网卡、IP、路由等信息。需要我们自己为Docker容器添加网卡、配置IP等。\n\nbridge模式\n当Docker进程启动时，会在主机上创建一个名为docker0的虚拟网桥，此主机上启动的Docker容器会连接到这个虚拟网桥上。虚拟网桥的工作方式和物理交换机类似，这样主机上的所有容器就通过交换机连在了一个二层网络中。\n\n从docker0子网中分配一个IP给容器使用，并设置docker0的IP地址为容器的默认网关。在主机上创建一对虚拟网卡veth pair设备，Docker将veth pair设备的一端放在新创建的容器中，并命名为eth0（容器的网卡），另一端放在主机中，以vethxxx这样类似的名字命名，并将这个网络设备加入到docker0网桥中。可以通过brctl show命令查看。\n\nbridge模式是docker的默认网络模式，不写–net参数，就是bridge模式。使用docker run -p时，docker实际是在iptables做了DNAT规则，实现端口转发功能。可以使用iptables -t nat -vnL查看。\n————————————————\n版权声明：本文为CSDN博主「LRY01127」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。\n原文链接：https://blog.csdn.net/weixin_56416440/article/details/124773678\n")])])]),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("安装oracle:\n docker pull registry.cn-hangzhou.aliyuncs.com/helowin/oracle_11g\n \n docker run -d --name oracle --net=host registry.cn-hangzhou.aliyuncs.com/helowin/oracle_11g\n \n docker exec -it oracle bash\n 切到root用户\n su \n \n helowin\n \n cd /home/oracle/app/oracle/product/11.2.0/dbhome_2/\n \n 配置环境变量\n vi /etc/profile\n加在最下面\nexport ORACLE_HOME=/home/oracle/app/oracle/product/11.2.0/dbhome_2/\nexport ORACLE_SID=helowin\nexport PATH=$PATH:$ORACLE_HOME/bin\n刷新环境变量\nsource /etc/profile\n切回oracle用户\nsu - oracle\n\n登录sqlplus\nsqlplus /nolog\n连接数据库用户\nSQL> conn /as sysdba;\n修改system用户\nalter user system identified by 123456;\nalter user sys identified by 123456;\nalter profile default limit PASSWORD_LIFE_TIME unlimited;\n")])])]),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("安装mysql：\ndocker pull mysql\n\nmkdir -p /data/mysql\nvim /data/mysql/my.cnf\n\n[client]\ndefault-character-set=utf8mb4\n[mysql]\ndefault-character-set=utf8mb4\n[mysqld]\ncharacter-set-server=utf8mb4\ndefault-time-zone=+8:00\nsecure_file_priv=NULL\nmax_allowed_packet=2G\n\ndocker run -d --name mysql --net=host -e MYSQL_ROOT_PASSWORD=123456 -v /data/mysql:/etc/mysql mysql\n\n三、连接MySQL\n1、进入mysql容器\ndocker exec -it mysql /bin/bash\n\n2、登陆mysql\nmysql -u root -p\n\n3、mysql 8 设置允许远程用户访问\nuse mysql;\nupdate user set host = '%' where user = 'root' and host='localhost'; # 更新root - localhost 为 root - %\n\nGRANT ALL ON *.* TO 'root'@'%'; # 设置允许远程用户访问\n\nflush privileges;# 刷新权限\n\nALTER USER 'root'@'%' IDENTIFIED WITH mysql_native_password BY '密码';#更新用户加密方式，mysql8默认的加密方式为caching_sha2_password 与mysql5的加密方式mysql_native_password 不同\n\n")])])]),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("mkdir -p /data/nginx/conf.d\nvi /data/nginx/conf.d/80.conf\n\nserver{\n        listen 80;\n\n        location / {\n                root /usr/share/nginx/html;\n        }\n}\n\n\ndocker run -d --name nginx --net=host --privileged -v /data/nginx/conf.d/:/etc/nginx/conf.d nginx\n")])])]),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('//拉取最新版本\ndocker pull redis\n去redis官网下载redis,然后在redis-7.0.0\\redis-7.0.0找到redis.conf文件\n\n修改文件中以下配置项：\n\n1.将bind 127.0.0.1 -::1注释掉\n# bind 127.0.0.1 -::1\n2.将 appendonly no 设置成yes,开启redis数据持久化 \n appendonly yes  \n3.将  requirepass foobared 解开注释，设置密码\n requirepass root\n在linux服务器中新建/home/redis/目录，将redis.conf文件上传至该目录\n\n使用如下命令运行redis容器\n\ndocker run  -p 6379:6379 --name myredis -v /home/redis/redis.conf:/etc/redis/redis.conf -v /home/redis/data:/data -d redis redis-server /etc/redis/redis.conf    --requirepass "root"\n\n')])])]),s("p",[s("a",{attrs:{href:"https://blog.csdn.net/chenjun_base/article/details/120996109",target:"_blank",rel:"noopener noreferrer"}},[e._v("(35条消息) 虚拟机中Linux扩容硬盘空间_chenjun_base的博客-CSDN博客_linux虚拟机扩容"),s("OutboundLink")],1)])])}),[],!1,null,null,null);s.default=a.exports}}]);